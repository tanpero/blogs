

> 太公推蓍蹈龟而曰：“枯骨死草，何知而凶？”
>
> ——《论衡》

周文王被囚禁在羑里。从天子的祭台上不时传来战俘被献祭时凄厉的叫声，这声音也许上达了帝廷，将使商朝获得新的庇佑。周文王双手颤栗，在木牍上落笔：

“扬于王庭，孚号有厉。”

蓍草被重新握在周文王冒汗的手心里。他深信商朝的气数不会太久，他的周国终有一日兴起而翦灭商朝，而他要亲自发现这一切的运数，昊天上帝将对虔诚的他做出指示。一组五十根的蓍草，分成几堆，周文王以一种只有他知晓的占卜方式摆弄它们，不断对每堆蓍草的数目进行模算术，从中聆听昊天上帝的声音。三千年后，我们把周文王手中占卜的蓍草称为随机数发生器。

随机数发生器是一种算法，在最理想的情况下，它可以生成一组无法被预测的数字序列。但是，考虑到任何算法都有确定的输出，因此通过编程方式计算随机数实际上是“伪装”一个随机数发生器，这样的算法被称为伪随机数发生器。

如果手上有一枚骰子，投掷它 20 次，可能会得到这样的结果：
$$
\Huge{\text{⚁ ⚀ ⚃ ⚃ ⚁}}\\\Huge{\text{⚄ ⚄ ⚁ ⚃ ⚄}}\\\Huge{\text{⚀ ⚂ ⚃ ⚄ ⚂}}\\\Huge{\text{⚅ ⚁ ⚁ ⚀ ⚄}}
$$
也有可能得到这样的极小概率的结果：
$$
\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\
$$
骰子的运动没有停下，我们就不知道它将会显示哪一面点数；如果只知道当前的点数，也无法推出上一次的点数。我们只知道每一面点数的出现概率都是 $\frac{1}{6}$。因此，骰子的点数具有不可预测性，或者说，随机性。

我们希望伪随机数发生器能模拟出如掷骰子一般样难以预测点数的效果。这样的算法将生成一个数字序列，它看起来也许会“很像”一个真正的随机数序列。十三世纪的方济各会埃德文修士曾设计过一种算法，它后来被作家博尔赫斯从梵蒂冈的故纸堆里重新发现，又被数学家冯诺依曼正式提出来，这就是平方取中法（Middle-square Method）。它的构造思路是这样的：

1. $x_n$ 是一个四位十进制数；
2. 计算 $x_n^2$，若位数不足八位，在最高位补 $0$；
3. $x_{n+1}$ 即为 $x^2_n$ 中间四位数。

设 $x_1=1234$，则可以写出 JavaScript 代码：
```js
let x = 1234
const middleSquare = () => x = Math.floor((x ** 2) / 100 % 10000)
```

输出 `middleSquare()` 十次，可以得到
$$
\text{5227}\\
\text{3215}\\
\text{3362}\\
\text{3030}\\
\text{1809}\\
\text{2724}\\
\text{4201}\\
\text{6484}\\
\text{422}\\
\text{1780}\\
$$
将输出进一步处理，就可以模拟出掷骰子的效果

```js
x = 1234
const getSymbol = n => ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'][n]
let result = []
for (let i = 0; i < 10; i++) {
    result.push(getSymbol(middleSquare() % 6))
}
console.log(result.join(" "))
```

得到
$$
\Huge{\text{⚁ ⚅ ⚂ ⚀ ⚃ ⚀ ⚁ ⚄ ⚂ ⚄}}
$$
在这个序列中，每个点数都会出现，似乎也无法从已知的点数序列预测下一个点数，就像真正的掷骰子的效果。这样，我们就实现了一个伪随机数发生器。但不难发现，这个序列并不随机，当 $x_1$ 给定时，序列中的 $x_2,\;x_3,\;\cdots x_n$ 就都是确定的了。更大的问题是，无论 $x_1$ 取几，序列中很快都会形成一个由相同数字反复出现的周期。 我们需要用更精确的语言去描述伪随机数发生器，从而分析和改进它的性质。

一个伪随机数发生器的数学模型是一个四元组 $(Q,\sigma,\Sigma,f)$，其中

- $Q$ 是有限状态集合
- $\sigma$ 是状态转移函数
- $\Sigma$ 是有限输出集合
- $f$ 是单射 $Q\rightarrow\Sigma$

设定初始状态 $q_0\in Q$，每一次输出

单独看这个序列，和前面掷骰子出来结果比较，看起来还是比较像，每个数字都出现了，看似没有什么规律性。那么我们模拟了一个随机过程——一个伪随机数序列。

这里将之为伪随机数序列，只因为它和真正的随机数序列比较而言，它实际上是确定的——在平方取中法中，当第一个 rand 确定时，后续序列的所有值也就随之确定，在这个过程中没有任何随机性。



若将 $\pi$ 的数字序列视为随机数序列，则其随机性并不良好。

Bailey-Borwein-Plouffe 公式
$$
\pi=\sum^\infty_{n=0}\frac{1}{16^n}\left(\frac{4}{8n+1}-\frac{2}{8n+4}-\frac{1}{8n+5}-\frac{1}{8n+6}\right)
$$
表明了 $\pi$ 在 16 进制下的可预测性。

一个伪随机数生成器无法通过任何多项式时间检验与真正的随机过程相区分，但是 $\pi$ 的数字显然可以通过多项式时间检验与随机过程相区分。