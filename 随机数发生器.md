

> 太公推蓍蹈龟而曰：“枯骨死草，何知而凶？”
>
> ——《论衡》

周文王被囚禁在羑里。从天子的祭台上不时传来战俘被献祭时凄厉的叫声，这声音也许上达了帝廷，将使商朝获得新的庇佑。周文王双手颤栗，在木牍上落笔：

“扬于王庭，孚号有厉。”

蓍草被重新握在周文王冒汗的手心里。他深信商朝的气数不会太久，他的周国终有一日兴起而翦灭商朝，而他要亲自发现这一切的运数，昊天上帝将对虔诚的他做出指示。一组五十根的蓍草，分成几堆，周文王以一种只有他知晓的占卜方式摆弄它们，不断对每堆蓍草的数目进行模算术，从中聆听昊天上帝的声音。三千年后，我们把周文王手中占卜的蓍草称为随机数发生器。

随机数发生器是一种算法，在最理想的情况下，它可以生成一组无法被预测的数字序列。但是，考虑到任何算法都有确定的输出，因此通过编程方式计算随机数实际上是“伪装”一个随机数发生器，这样的算法被称为伪随机数发生器。

如果手上有一枚骰子，投掷它 20 次，可能会得到这样的结果：
$$
\Huge{\text{⚁ ⚀ ⚃ ⚃ ⚁}}\\\Huge{\text{⚄ ⚄ ⚁ ⚃ ⚄}}\\\Huge{\text{⚀ ⚂ ⚃ ⚄ ⚂}}\\\Huge{\text{⚅ ⚁ ⚁ ⚀ ⚄}}
$$
也有可能得到这样的极小概率的结果：
$$
\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\\Huge{\text{⚅ ⚅ ⚅ ⚅ ⚅}}\\
$$
骰子的运动没有停下，我们就不知道它将会显示哪一面点数；如果只知道当前的点数，也无法推出上一次的点数。我们只知道每一面点数的出现概率都是 $\frac{1}{6}$。因此，骰子的点数具有不可预测性，或者说，随机性。

我们希望伪随机数发生器能模拟出如掷骰子一般样难以预测点数的效果。这样的算法将生成一个数字序列，它看起来也许会“很像”一个真正的随机数序列。十三世纪的方济各会埃德文修士曾设计过一种算法，它后来被作家博尔赫斯从梵蒂冈的故纸堆里重新发现，又被数学家冯诺依曼正式提出来，这就是平方取中法（Middle-square Method）。它的构造思路是这样的：

1. 已知要获得 $m$ 位的十进制随机数，给定一个这样的数 $x_n$ ；
2. 计算 $x_n^2$，若位数不足 $2m$ 位，在最高位补 $0$；
3. 取 $x^2_n$ 的中间 $m$ 位数，即为所求的 $x_{n+1}$。

设 $x_1=1234$，则可以写出 JavaScript 代码：
```js
let x = 1234
const middleSquare = () => x = Math.floor((x ** 2) / 100 % 10000)
```

输出 `middleSquare()` 十次，可以得到
$$
\text{5227}\\
\text{3215}\\
\text{3362}\\
\text{3030}\\
\text{1809}\\
\text{2724}\\
\text{4201}\\
\text{6484}\\
\text{422}\\
\text{1780}\\
$$
将输出进一步处理，就可以模拟出掷骰子的效果

```js
x = 1234
const getSymbol = n => ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'][n]
let result = []
for (let i = 0; i < 10; i++) {
    result.push(getSymbol(middleSquare() % 6))
}
console.log(result.join(" "))
```

得到
$$
\Huge{\text{⚁ ⚅ ⚂ ⚀ ⚃ ⚀ ⚁ ⚄ ⚂ ⚄}}
$$
在这个序列中，每个点数都会出现，似乎也无法从已知的点数序列预测下一个点数，就像真正的掷骰子的效果。这样，我们就实现了一个伪随机数发生器。但不难发现，这个序列并不随机，当 $x_1$ 给定时，序列中的 $x_2,\;x_3,\;\cdots x_n$ 就都是确定的了。更大的问题是，无论 $x_1$ 取几，序列中很快都会形成一个由相同数字反复出现的周期。 我们需要用更精确的语言去描述伪随机数发生器，从而分析和改进它的性质。

一个伪随机数发生器的数学模型是一个四元组 $(Q,\sigma,\Sigma,f)$，其中

- $Q$ 是有限状态集合
- $\sigma$ 是状态转移函数
- $\Sigma$ 是有限输出集合
- $f$ 是单射 $Q\rightarrow\Sigma$

设定初始状态 $q_0\in Q$，要获得的随机数为 $x_n$，则
$$
q_n = \sigma(q_{n-1})\\
x_n=f(q_n),\;x_n\in\Sigma
$$
对于平方取中法，若随机数的范围是四位十进制数，那么
$$
Q=[0,9999]\cap N\\
\sigma=\text{平方取中法的计算过程}\\
\Sigma=[0,9999]\cap N\\
f=q_n
$$
很明显，当 $q_n$ 被确定了，任意的 $x_n$ 都是可以被预测的；更一般地说，对于任何伪随机数发生器和任何初始状态而言，其所有可能生成的随机数的序列都存在周期。这个事实类似于物理实验中的测量误差：应当尽量优化方法以减少其影响，但是始终存在。人们有另外的办法从大自然中为计算机获取真正的随机数，包括电子元件的热噪声、放射性物质的衰变情况、大气中的自然噪声、雪崩二极管的放电、宇宙射线、熔岩灯、键盘敲击。大部分情况下，我们不需要使用这些手段获取真正的随机数，一个定义良好的伪随机数发生器生成的序列，可以非常接近真正的随机数序列，这就足够满足需求了。

怎样算是“定义良好”？第一层要求是生成的随机序列段具有高度的唯一性，从可能产生的随机数序列中任取两个长度一样的序列段，它们相同的概率要能忽略不计；第二层要求是数字分布情况的自相关检测等统计指标要高度近似真正的自然随机数。大部分情况下，满足这两层要求即可。有些场合需要防范随机数序列被蓄意攻击者破解，那么还需要满足以下两层要求：第三层要求是，对于某一组已知的随机数，外人无法据此确定随机数发生器的当前状态 $q_n$、整个随机数序列中在这之前的数和在这之后的数；第四层要求更进一步，即便当前内部状态 $q_n$ 被知晓了，也无法计算先前内部状态 $q_{n-1}$ 和先前的数 $x_{n-1}$。

如果我们要设计自己的伪随机数发生器，它生成的随机数序列的周期应当很长。假设最简单的伪随机数发生器是计算 $\frac{1}{7}$ 的第 $n$ 位，由于 $\frac{1}{7}=0.142857142857142857\cdots$，这个伪随机数发生器的周期就是 $6$。理想的伪随机数发生器的序列的周期非常长，往往大于 $10^{10}$，使得在一般应用场景中不会超出这个周期；它生成的随机数序列里的数字应该彼此不相关，也就是“没有规律”。对于伪随机数发生器生成的数字序列，外人无法通过任何多项式时间检验将其与真正的随机过程相区分。

有一个很自然的思路是使用 $\pi$ 的数字序列作为随机数序列。$\pi$ 是超越数，压根不存在序列周期；$\pi$ ；现代数学实验猜测 $\pi$ 很可能是一个正规数，所以其数字序列看起来会是随机分布的。那么可以用 $\pi$ 获得随机数吗？

不可以。Bailey-Borwein-Plouffe 公式
$$
\pi=\sum^\infty_{n=0}\frac{1}{16^n}\left(\frac{4}{8n+1}-\frac{2}{8n+4}-\frac{1}{8n+5}-\frac{1}{8n+6}\right)
$$
表明了 $\pi$ 的数字序列的可预测性，在 16 进制下尤为明显。$\pi$ 的数字序列显然可以通过多项式时间检验与随机过程相区分。

二十世纪五十年代，G.E.Forsythe 用 16 个四位十进制数初始值对平方取中法进行实验，发现其中的 12 个导致了以循环 $6100,\;2100,\;4100,\;8100,\;6100,\;\cdots$ 为结局的序列，有 2 个收敛到 0。N.Metropolis 证明了用二十位数字生成的序列可能退化成 13 个不同的短循环，最长的循环周期长度为 142。基于平方取中法的伪随机数发生器不应当被考虑。

D.H.Lehmer 在 1949 年提出了线性同余法，从而设计出线性同余生成器。它的状态转移函数 $\sigma$ 定义为
$$
q_{n+1}=(aq_n+c)\mathrm{mod\;} m
$$
$a$、$c$、$m$ 是另外取定的值。并有
$$
Q=[0,m-1]\cap N\\
\Sigma=[0,m-1]\cap N\\
f=q_n
$$
实验表明，$a$、$c$、$m$ 的取值对生成的随机数序列的影响很大。